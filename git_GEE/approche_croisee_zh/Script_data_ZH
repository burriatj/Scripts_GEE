/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var ROI = 
    /* color: #d63000 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[-2.290919302030774, 47.44197699340455],
          [-2.290919302030774, 47.32504986728041],
          [-2.0087079983198364, 47.32504986728041],
          [-2.0087079983198364, 47.44197699340455]]], null, false);
/***** End of imports. If edited, may not auto-convert in the playground. *****/
/////// TELECHARGEMENT DES COUCHES POUR LA CLASSIFICATION DES ZONES HUMIDES /////////


//  AVANT DE LANCER LE SCRIPT :

// IL FAUT AJOUTER L'EMPRISE DE CALCUL ET SORTIE DE DONNEES DANS LA PARTIE "Assets" SUR LE 
// NAVIGATEUR A GAUCHE DE LA CONSOLE (en format .shp), PUIS L'APPELER DANS LE SCRIPT
// (sélectionner tous les fichiers associés sauf le .qmd)

// Pour modifier la zone d'étude, remplacer ROI dans la ligne ci-dessous par le nom de la zone (en violet)
var AOI = ROI;

// Indiquer le SCR de la zone (en rouge)
var CRSzone = 'EPSG: 2154';


// Nommer le dossier dans lequel enregistrer les données (en rouge)
var dossier = 'data_ROI';


// Le 1er SCRIPT PERMET DE SORTIR DES BANDES CALCULEES ISSUES DE DONNEES SENTINEL 1 ET 2
// LES BANDES SONT DES MOYENNES HAUTES ET DES MOYENNES BASSES
// CES SORTIES SONT UTILES NOTAMMENT POUR LA DETECTION DE NIVEAUX D'HUMIDITE ET DES LITS MINEURS ET MAJEURS DES COURS D'EAU

// Le 2eme SCRIPT PERMET DE SORTIR DES BANDES CALCULEES ISSUES DE DONNEES SENTINEL 1 ET 2
// LES BANDES DES REDUCTIONS STATISTIQUES, DES INDICES SPECTRAUX ET DES TEXTURES
// CES SORTIES SONT UTILES NOTAMMENT POUR LA DETECTION DE NIVEAUX D'HUMIDITE ET DES VEGETATIONS DES ZH



//      LA PERIODE 0  COURT SUR   Janvier-Septembre 2020 à 2022
//      LA PERIODE 1  COURT SUR   Janvier-Mars 2020 à 2022
//      LA PERIODE 2  COURT SUR   Avril-Juin 2020 à 2022
//      LA PERIODE 3  COURT SUR   Juillet-Septembre 2020 à 2022
//      LA PERIODE 4  COURT SUR   Octobre-Décembre 2020 à 2022

                                                            Map.centerObject(ROI,10);
                                                            Map.setOptions('SATELLITE');

////////////////////////////// DEBUT _Script_moy_BASSE_HAUTE_interA /////////////////////////////



/////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////// RADAR //////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

                         //////////////////// PERIODE 1 ////////////////////////////

var s1 = ee.ImageCollection('COPERNICUS/S1_GRD')
        .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH'))
        .filter(ee.Filter.or(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'), ee.Filter.eq('orbitProperties_pass','ASCENDING')));

var filtered1 = s1
  .filter(ee.Filter.date('2022-01-01','2022-03-31'))
  .filter(ee.Filter.bounds(ROI));
  
var filtered2 = s1
  .filter(ee.Filter.date('2021-01-01','2021-03-31'))
  .filter(ee.Filter.bounds(ROI));
  
var filtered3 = s1
  .filter(ee.Filter.date('2020-01-01','2020-03-31'))
  .filter(ee.Filter.bounds(ROI));
  
var dataset = filtered1.merge(filtered2).merge(filtered3);

print('S1 - Collection P1',dataset.size());

//reduction _meanb
var im_meanb = dataset.reduce({
reducer: ee.Reducer.intervalMean(0, 5)});
var reprojected = im_meanb.reproject(CRSzone, null, 10);
var clipped_image = reprojected.clip(ROI);
var vvmeanb_1 = clipped_image.select('VV_mean');
Map.addLayer(vvmeanb_1,{min:-25,max:5},'vvmeanb_1_01_03');

                         //////////////////// PERIODE 3 ////////////////////////////

var s1 = ee.ImageCollection('COPERNICUS/S1_GRD')
        .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH'))
        .filter(ee.Filter.or(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'), ee.Filter.eq('orbitProperties_pass','ASCENDING')));

var filtered1 = s1
  .filter(ee.Filter.date('2022-07-01','2022-09-30'))
  .filter(ee.Filter.bounds(ROI));
  
var filtered2 = s1
  .filter(ee.Filter.date('2021-07-01','2021-09-30'))
  .filter(ee.Filter.bounds(ROI));
  
var filtered3 = s1
  .filter(ee.Filter.date('2020-07-01','2020-09-30'))
  .filter(ee.Filter.bounds(ROI));
  
var dataset = filtered1.merge(filtered2).merge(filtered3);

print('S1 - Collection P3',dataset.size());

//reduction _meanh
var im_meanh = dataset.reduce({
reducer: ee.Reducer.intervalMean(80, 95)});
var reprojected = im_meanh.reproject(CRSzone, null, 10);
var clipped_image = reprojected.clip(ROI);
var vvmeanh_3 = clipped_image.select('VV_mean');
//Map.addLayer(vvmeanh_3,{min:-25,max:5},'vvmeanh_3_07_09');

/////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////// EXPORT ////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////// EXPORT PERIODE 1 ////////////////////////////

var vvmeanb_1 = vvmeanb_1.clip(ROI);
Export.image.toDrive({
  image: vvmeanb_1 
 , folder: dossier,
  description: 'vvmeanb_1',
  scale: 10,
  maxPixels: 1303663927,
  crs:CRSzone,
  crsTransform:'',
  region: ROI
});

//////////////////// EXPORT PERIODE 3 ////////////////////////////

var vvmeanh_3 = vvmeanh_3.clip(ROI);
Export.image.toDrive({
  image: vvmeanh_3 
 , folder: dossier,
  description: 'vvmeanh_3',
  scale: 10,
  maxPixels: 1303663927,
  crs:CRSzone,
  crsTransform:'',
  region: ROI
});

/////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////// Optique ////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

                            //////////////////// PERIODE 1 ////////////////////


var s2 = ee.ImageCollection("COPERNICUS/S2_SR_HARMONIZED");

var filtered1 = s2
  .filter(ee.Filter.date('2022-01-01','2022-03-31'))
  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 50))
  .filter(ee.Filter.bounds(ROI));
  
var filtered2 = s2
  .filter(ee.Filter.date('2021-01-01','2021-03-31'))
  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 50))
  .filter(ee.Filter.bounds(ROI));
  
var filtered3 = s2
  .filter(ee.Filter.date('2020-01-01','2020-03-31'))
  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 50))
  .filter(ee.Filter.bounds(ROI));
  
var filtered = filtered1.merge(filtered2).merge(filtered3);

print('S2 - Collection P1',filtered.size());

// Write a function for Cloud masking
function maskCloudAndShadowsSR(image) {
  var cloudProb = image.select('MSK_CLDPRB');
  var snowProb = image.select('MSK_SNWPRB');
  var cloud = cloudProb.lt(5);
  var snow = snowProb.lt(5);
  var scl = image.select('SCL'); 
  var shadow = scl.eq(3); // 3 = cloud shadow
  var cirrus = scl.eq(10); // 10 = cirrus
  // Cloud probability less than 5% or cloud shadow classification
  var mask = (cloud.and(snow)).and(cirrus.neq(1)).and(shadow.neq(1));
  return image.updateMask(mask).divide(10000)
      .select("B.*")
      .copyProperties(image, ["system:time_start"]);
}

var filtered = filtered.map(maskCloudAndShadowsSR)

// Add a band containing timestamp to each image
// This will be used to do pixel-wise interpolation later
var filtered = filtered.map(function(image) {
  var timeImage = image.metadata('system:time_start').rename('timestamp')
  // The time image doesn't have a mask. 
  // We set the mask of the time band to be the same as the first band of the image
  var timeImageMasked = timeImage.updateMask(image.mask().select(0))
  return image.addBands(timeImageMasked)
})

// Specify the time-window
// This will determine how much backward and forward are we willing to
// look for an unmasked pixel in the time-series
var days = 30

// For each image in the collection, we need to find all images
// before and after the specified time-window

// This is accomplished using Joins
// We need to do 2 joins
// Join 1: Join the collection with itself to find all images before each image
// Join 2: Join the collection with itself to find all images after each image

// We first define the filters needed for the join

// Define a maxDifference filter to find all images within the specified days
// The filter needs the time difference in milliseconds
// Convert days to milliseconds
var millis = ee.Number(days).multiply(1000*60*60*24)
var maxDiffFilter = ee.Filter.maxDifference({
  difference: millis,
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})

// We need a lessThanOrEquals filter to find all images after a given image
// This will compare the given image's timestamp against other images' timestamps
var lessEqFilter = ee.Filter.lessThanOrEquals({
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})

// We need a greaterThanOrEquals filter to find all images before a given image
// This will compare the given image's timestamp against other images' timestamps
var greaterEqFilter = ee.Filter.greaterThanOrEquals({
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})

// Apply the joins

// For the first join, we need to match all images that are after the given image.
// To do this we need to match 2 conditions
// 1. The resulting images must be within the specified time-window of target image
// 2. The target image's timestamp must be lesser than the timestamp of resulting images
// Combine two filters to match both these conditions
var filter1 = ee.Filter.and(maxDiffFilter, lessEqFilter)
// This join will find all images after, sorted in descending order
// This will gives us images so that closest is last
var join1 = ee.Join.saveAll({
  matchesKey: 'after',
  ordering: 'system:time_start',
  ascending: false})
  
var join1Result = join1.apply({
  primary: filtered,
  secondary: filtered,
  condition: filter1
})
// Each image now as a property called 'after' containing
// all images that come after it within the time-window
print(join1Result.first())

// Do the second join now to match all images within the time-window
// that come before each image
var filter2 = ee.Filter.and(maxDiffFilter, greaterEqFilter)
// This join will find all images before, sorted in ascending order
// This will gives us images so that closest is last
var join2 = ee.Join.saveAll({
  matchesKey: 'before',
  ordering: 'system:time_start',
  ascending: true})
  
var join2Result = join2.apply({
  primary: join1Result,
  secondary: join1Result,
  condition: filter2
})

// Each image now as a property called 'before' containing
// all images that come after it within the time-window
print(join2Result.first())


// Do the interpolation

// We now write a function that will be used to interpolate all images
// This function takes an image and replaces the masked pixels
// with the interpolated value from before and after images.

var interpolateImages = function(image) {
  var image = ee.Image(image)
  // We get the list of before and after images from the image property
  // Mosaic the images so we a before and after image with the closest unmasked pixel
  var beforeImages = ee.List(image.get('before'))
  var beforeMosaic = ee.ImageCollection.fromImages(beforeImages).mosaic()
  var afterImages = ee.List(image.get('after'))
  var afterMosaic = ee.ImageCollection.fromImages(afterImages).mosaic()

  // Interpolation formula
  // y = y1 + (y2-y1)*((t – t1) / (t2 – t1))
  // y = interpolated image
  // y1 = before image
  // y2 = after image
  // t = interpolation timestamp
  // t1 = before image timestamp
  // t2 = after image timestamp
  
  // We first compute the ratio (t – t1) / (t2 – t1)

  // Get image with before and after times
  var t1 = beforeMosaic.select('timestamp').rename('t1')
  var t2 = afterMosaic.select('timestamp').rename('t2')

  var t = image.metadata('system:time_start').rename('t')

  var timeImage = ee.Image.cat([t1, t2, t])

  var timeRatio = timeImage.expression('(t - t1) / (t2 - t1)', {
    't': timeImage.select('t'),
    't1': timeImage.select('t1'),
    't2': timeImage.select('t2'),
  })
  // You can replace timeRatio with a constant value 0.5
  // if you wanted a simple average
  
  // Compute an image with the interpolated image y
  var interpolated = beforeMosaic
    .add((afterMosaic.subtract(beforeMosaic).multiply(timeRatio)))
  // Replace the masked pixels in the current image with the average value
  var result = image.unmask(interpolated)
  return result.copyProperties(image, ['system:time_start'])
}

// map() the function to interpolate all images in the collection
var dataset = ee.ImageCollection(join2Result.map(interpolateImages))

//reduction _mean
var im_mean = dataset.reduce({
reducer: ee.Reducer.intervalMean(10, 90)});

//reduction _meanb
var im_meanb = dataset.reduce({
reducer: ee.Reducer.intervalMean(5, 20)});

//reduction _meanh
var im_meanh = dataset.reduce({
reducer: ee.Reducer.intervalMean(80, 95)});

var image = im_mean.addBands(im_meanb).addBands(im_meanh);

var reprojected = image
        .reproject(CRSzone, null, 10);

var final_image = reprojected.clip(ROI);

var ndvi1b = final_image.expression ('(nir - red) / (nir + red)', {
      'nir': final_image.select('B8_mean_1'),
      'red': final_image.select('B4_mean'),
}).rename('ndvi1b');
//Map.addLayer(ndvi1b,{min:0,max:1, palette: ['red', 'yellow', 'green']},'ndvi1b_01_03');

var evi1b = final_image.expression ('(2.5*nir-red*(nir+6*red-7.5*bleue)+1)', {
      'nir': final_image.select('B8_mean_1'),
      'red': final_image.select('B4_mean'),
      'bleue': final_image.select('B2_mean'),
}).rename('evi1b');
//Map.addLayer(evi1b,{min:1,max:2},'evi1b_01_03');

                            //////////////////// PERIODE 3 ////////////////////


var s2 = ee.ImageCollection("COPERNICUS/S2_SR_HARMONIZED");

var filtered1 = s2
  .filter(ee.Filter.date('2022-07-01','2022-09-30'))
  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 50))
  .filter(ee.Filter.bounds(ROI));
  
var filtered2 = s2
  .filter(ee.Filter.date('2021-07-01','2021-09-30'))
  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 50))
  .filter(ee.Filter.bounds(ROI));
  
var filtered3 = s2
  .filter(ee.Filter.date('2020-07-01','2020-09-30'))
  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 50))
  .filter(ee.Filter.bounds(ROI));
  
var filtered = filtered1.merge(filtered2).merge(filtered3);

print('S2 - Collection P3',filtered.size());

// Write a function for Cloud masking
function maskCloudAndShadowsSR(image) {
  var cloudProb = image.select('MSK_CLDPRB');
  var snowProb = image.select('MSK_SNWPRB');
  var cloud = cloudProb.lt(5);
  var snow = snowProb.lt(5);
  var scl = image.select('SCL'); 
  var shadow = scl.eq(3); // 3 = cloud shadow
  var cirrus = scl.eq(10); // 10 = cirrus
  // Cloud probability less than 5% or cloud shadow classification
  var mask = (cloud.and(snow)).and(cirrus.neq(1)).and(shadow.neq(1));
  return image.updateMask(mask).divide(10000)
      .select("B.*")
      .copyProperties(image, ["system:time_start"]);
}

var filtered = filtered.map(maskCloudAndShadowsSR)

// Add a band containing timestamp to each image
// This will be used to do pixel-wise interpolation later
var filtered = filtered.map(function(image) {
  var timeImage = image.metadata('system:time_start').rename('timestamp')
  // The time image doesn't have a mask. 
  // We set the mask of the time band to be the same as the first band of the image
  var timeImageMasked = timeImage.updateMask(image.mask().select(0))
  return image.addBands(timeImageMasked)
})

// Specify the time-window
// This will determine how much backward and forward are we willing to
// look for an unmasked pixel in the time-series
var days = 30

// For each image in the collection, we need to find all images
// before and after the specified time-window

// This is accomplished using Joins
// We need to do 2 joins
// Join 1: Join the collection with itself to find all images before each image
// Join 2: Join the collection with itself to find all images after each image

// We first define the filters needed for the join

// Define a maxDifference filter to find all images within the specified days
// The filter needs the time difference in milliseconds
// Convert days to milliseconds
var millis = ee.Number(days).multiply(1000*60*60*24)
var maxDiffFilter = ee.Filter.maxDifference({
  difference: millis,
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})

// We need a lessThanOrEquals filter to find all images after a given image
// This will compare the given image's timestamp against other images' timestamps
var lessEqFilter = ee.Filter.lessThanOrEquals({
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})

// We need a greaterThanOrEquals filter to find all images before a given image
// This will compare the given image's timestamp against other images' timestamps
var greaterEqFilter = ee.Filter.greaterThanOrEquals({
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})

// Apply the joins

// For the first join, we need to match all images that are after the given image.
// To do this we need to match 2 conditions
// 1. The resulting images must be within the specified time-window of target image
// 2. The target image's timestamp must be lesser than the timestamp of resulting images
// Combine two filters to match both these conditions
var filter1 = ee.Filter.and(maxDiffFilter, lessEqFilter)
// This join will find all images after, sorted in descending order
// This will gives us images so that closest is last
var join1 = ee.Join.saveAll({
  matchesKey: 'after',
  ordering: 'system:time_start',
  ascending: false})
  
var join1Result = join1.apply({
  primary: filtered,
  secondary: filtered,
  condition: filter1
})
// Each image now as a property called 'after' containing
// all images that come after it within the time-window
print(join1Result.first())

// Do the second join now to match all images within the time-window
// that come before each image
var filter2 = ee.Filter.and(maxDiffFilter, greaterEqFilter)
// This join will find all images before, sorted in ascending order
// This will gives us images so that closest is last
var join2 = ee.Join.saveAll({
  matchesKey: 'before',
  ordering: 'system:time_start',
  ascending: true})
  
var join2Result = join2.apply({
  primary: join1Result,
  secondary: join1Result,
  condition: filter2
})

// Each image now as a property called 'before' containing
// all images that come after it within the time-window
print(join2Result.first())


// Do the interpolation

// We now write a function that will be used to interpolate all images
// This function takes an image and replaces the masked pixels
// with the interpolated value from before and after images.

var interpolateImages = function(image) {
  var image = ee.Image(image)
  // We get the list of before and after images from the image property
  // Mosaic the images so we a before and after image with the closest unmasked pixel
  var beforeImages = ee.List(image.get('before'))
  var beforeMosaic = ee.ImageCollection.fromImages(beforeImages).mosaic()
  var afterImages = ee.List(image.get('after'))
  var afterMosaic = ee.ImageCollection.fromImages(afterImages).mosaic()

  // Interpolation formula
  // y = y1 + (y2-y1)*((t – t1) / (t2 – t1))
  // y = interpolated image
  // y1 = before image
  // y2 = after image
  // t = interpolation timestamp
  // t1 = before image timestamp
  // t2 = after image timestamp
  
  // We first compute the ratio (t – t1) / (t2 – t1)

  // Get image with before and after times
  var t1 = beforeMosaic.select('timestamp').rename('t1')
  var t2 = afterMosaic.select('timestamp').rename('t2')

  var t = image.metadata('system:time_start').rename('t')

  var timeImage = ee.Image.cat([t1, t2, t])

  var timeRatio = timeImage.expression('(t - t1) / (t2 - t1)', {
    't': timeImage.select('t'),
    't1': timeImage.select('t1'),
    't2': timeImage.select('t2'),
  })
  // You can replace timeRatio with a constant value 0.5
  // if you wanted a simple average
  
  // Compute an image with the interpolated image y
  var interpolated = beforeMosaic
    .add((afterMosaic.subtract(beforeMosaic).multiply(timeRatio)))
  // Replace the masked pixels in the current image with the average value
  var result = image.unmask(interpolated)
  return result.copyProperties(image, ['system:time_start'])
}

// map() the function to interpolate all images in the collection
var dataset = ee.ImageCollection(join2Result.map(interpolateImages))

//reduction _mean
var im_mean = dataset.reduce({
reducer: ee.Reducer.intervalMean(10, 90)});

//reduction _meanb
var im_meanb = dataset.reduce({
reducer: ee.Reducer.intervalMean(5, 20)});

//reduction _meanh
var im_meanh = dataset.reduce({
reducer: ee.Reducer.intervalMean(80, 95)});

var image = im_mean.addBands(im_meanb).addBands(im_meanh);

var reprojected = image
        .reproject(CRSzone, null, 10);

var final_image = reprojected.clip(ROI);

var ndvi3h = final_image.expression ('(nir - red) / (nir + red)', {
      'nir': final_image.select('B8_mean_2'),
      'red': final_image.select('B4_mean'),
}).rename('ndvi3h');
//Map.addLayer(ndvi3h,{min:0,max:1, palette: ['red', 'yellow', 'green']},'ndvi3h_07_09');

var evi3h = final_image.expression ('(2.5*nir-red*(nir+6*red-7.5*bleue)+1)', {
      'nir': final_image.select('B8_mean_2'),
      'red': final_image.select('B4_mean'),
      'bleue': final_image.select('B2_mean'),
}).rename('evi3b');
//Map.addLayer(evi3h,{min:1,max:2},'evi3h_07_09');

/////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////// EXPORT ////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////// EXPORT PERIODE 1 ////////////////////////////

var ndvi1b = ndvi1b.clip(ROI);
Export.image.toDrive({
  image: ndvi1b
 , folder: dossier,
  description: 'ndvi1b',
  scale: 10,
  maxPixels: 1303663927,
  crs:CRSzone,
  crsTransform:'',
  region: ROI
});

var evi1b = evi1b.clip(ROI);
Export.image.toDrive({
  image: evi1b 
 , folder: dossier,
  description: 'evi1b',
  scale: 10,
  maxPixels: 1303663927,
  crs:CRSzone,
  crsTransform:'',
  region: ROI
});

//////////////////// EXPORT PERIODE 3 ////////////////////////////

var ndvi3h = ndvi3h.clip(ROI);
Export.image.toDrive({
  image: ndvi3h 
 , folder: dossier,
  description: 'ndvi3h',
  scale: 10,
  maxPixels: 1303663927,
  crs:CRSzone,
  crsTransform:'',
  region: ROI
});

var evi3h = evi3h.clip(ROI);
Export.image.toDrive({
  image: evi3h 
 , folder: dossier,
  description: 'evi3h',
  scale: 10,
  maxPixels: 1303663927,
  crs:CRSzone,
  crsTransform:'',
  region: ROI
});


////////////////////////////// DEBUT _Script_Donnees_TLD /////////////////////////////


////////////////////////////////////////////////// Radar ////////////////////////////////////////////////////


//Sentinel 1

	//Collection et temporalite
	
                         ////////////////////PERIODE 1////////////////////////////

var dataset = ee.ImageCollection('COPERNICUS/S1_GRD')
        .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH'))
        .filter(ee.Filter.or(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'), ee.Filter.eq('orbitProperties_pass','ASCENDING')));
        
var image_serie = dataset
  .filter(ee.Filter.date('2022-01-01','2022-03-31'))
  .filter(ee.Filter.bounds(ROI));
  
print('S1 - Collection P1',image_serie.size());

	//reduction serie
var im_p5 = image_serie.reduce({
reducer: ee.Reducer.percentile([5])});
var reprojected7 = im_p5.reproject(CRSzone, null, 10);
var clipped_image7 = reprojected7.clip(ROI);
var vv_p5_1 = clipped_image7.select('VV_p5');
//Map.addLayer(vv_p5_1,{min:-25,max:5},'VV_p5_01_03');

                        /////////////////////////PERIODE 2////////////////////////////////

var dataset = ee.ImageCollection('COPERNICUS/S1_GRD')
        .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH'))
        .filter(ee.Filter.or(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'), ee.Filter.eq('orbitProperties_pass','ASCENDING')));
        
var image_serie = dataset
  .filter(ee.Filter.date('2022-04-01','2022-06-30'))
  .filter(ee.Filter.bounds(ROI));
  
print('S1 - Collection P2',image_serie.size());

	//reduction serie
var im_p5 = image_serie.reduce({
reducer: ee.Reducer.percentile([5])});
var reprojected7 = im_p5.reproject(CRSzone, null, 10);
var clipped_image7 = reprojected7.clip(ROI);
var vv_p5_2 = clipped_image7.select('VV_p5');
//Map.addLayer(vv_p5_2,{min:-25,max:5},'VV_p5_04_06');

                            ////////////////// PERIODE 3 /////////////////

                            ////////////////// PERIODE 3 /////////////////

var dataset = ee.ImageCollection('COPERNICUS/S1_GRD')
        .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH'))
        .filter(ee.Filter.or(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'), ee.Filter.eq('orbitProperties_pass','ASCENDING')));
        
var image_serie = dataset
    .filter(ee.Filter.date('2022-07-01','2022-09-30'))
    .filter(ee.Filter.bounds(ROI));
    
print('S1 - Collection P3',image_serie.size());

	//reduction serie
var im_p5 = image_serie.reduce({
reducer: ee.Reducer.percentile([5])});
var reprojected7 = im_p5.reproject(CRSzone, null, 10);
var clipped_image7 = reprojected7.clip(ROI);
var vv_p5_3 = clipped_image7.select('VV_p5');
//Map.addLayer(vv_p5_3,{min:-25,max:5},'VV_p5_07_09');


                              //////////////////// PERIODE 4 ///////////////////////

var dataset = ee.ImageCollection('COPERNICUS/S1_GRD')
        .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH'))
        .filter(ee.Filter.or(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'), ee.Filter.eq('orbitProperties_pass','ASCENDING')));
        
var image_serie = dataset
  .filter(ee.Filter.date('2022-10-01','2022-12-31'))
  .filter(ee.Filter.bounds(ROI));

print('S1 - Collection P4',image_serie.size());

	//reduction serie
var im_p5 = image_serie.reduce({
reducer: ee.Reducer.percentile([5])});
var reprojected7 = im_p5.reproject(CRSzone, null, 10);
var clipped_image7 = reprojected7.clip(ROI);
var vv_p5_4 = clipped_image7.select('VV_p5');
//Map.addLayer(vv_p5_4,{min:-25,max:5},'VV_p5_07_09');

/////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////// Optique ////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////


                            //////////////////// PERIODE 1 ////////////////////


var s2 = ee.ImageCollection("COPERNICUS/S2_SR_HARMONIZED");

var filtered = s2
  .filter(ee.Filter.date('2022-01-01','2022-03-31'))
  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 50))
  .filter(ee.Filter.bounds(ROI))

print('S2 - Collection P1',filtered.size());

// Write a function for Cloud masking
function maskCloudAndShadowsSR(image) {
  var cloudProb = image.select('MSK_CLDPRB');
  var snowProb = image.select('MSK_SNWPRB');
  var cloud = cloudProb.lt(5);
  var snow = snowProb.lt(5);
  var scl = image.select('SCL'); 
  var shadow = scl.eq(3); // 3 = cloud shadow
  var cirrus = scl.eq(10); // 10 = cirrus
  // Cloud probability less than 5% or cloud shadow classification
  var mask = (cloud.and(snow)).and(cirrus.neq(1)).and(shadow.neq(1));
  return image.updateMask(mask).divide(10000)
      .select("B.*")
      .copyProperties(image, ["system:time_start"]);
}

var filtered = filtered.map(maskCloudAndShadowsSR)

// Add a band containing timestamp to each image
// This will be used to do pixel-wise interpolation later
var filtered = filtered.map(function(image) {
  var timeImage = image.metadata('system:time_start').rename('timestamp')
  // The time image doesn't have a mask. 
  // We set the mask of the time band to be the same as the first band of the image
  var timeImageMasked = timeImage.updateMask(image.mask().select(0))
  return image.addBands(timeImageMasked)
})

// Specify the time-window
// This will determine how much backward and forward are we willing to
// look for an unmasked pixel in the time-series
var days = 30

// For each image in the collection, we need to find all images
// before and after the specified time-window

// This is accomplished using Joins
// We need to do 2 joins
// Join 1: Join the collection with itself to find all images before each image
// Join 2: Join the collection with itself to find all images after each image

// We first define the filters needed for the join

// Define a maxDifference filter to find all images within the specified days
// The filter needs the time difference in milliseconds
// Convert days to milliseconds
var millis = ee.Number(days).multiply(1000*60*60*24)
var maxDiffFilter = ee.Filter.maxDifference({
  difference: millis,
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})

// We need a lessThanOrEquals filter to find all images after a given image
// This will compare the given image's timestamp against other images' timestamps
var lessEqFilter = ee.Filter.lessThanOrEquals({
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})

// We need a greaterThanOrEquals filter to find all images before a given image
// This will compare the given image's timestamp against other images' timestamps
var greaterEqFilter = ee.Filter.greaterThanOrEquals({
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})

// Apply the joins

// For the first join, we need to match all images that are after the given image.
// To do this we need to match 2 conditions
// 1. The resulting images must be within the specified time-window of target image
// 2. The target image's timestamp must be lesser than the timestamp of resulting images
// Combine two filters to match both these conditions
var filter1 = ee.Filter.and(maxDiffFilter, lessEqFilter)
// This join will find all images after, sorted in descending order
// This will gives us images so that closest is last
var join1 = ee.Join.saveAll({
  matchesKey: 'after',
  ordering: 'system:time_start',
  ascending: false})
  
var join1Result = join1.apply({
  primary: filtered,
  secondary: filtered,
  condition: filter1
})
// Each image now as a property called 'after' containing
// all images that come after it within the time-window
print(join1Result.first())

// Do the second join now to match all images within the time-window
// that come before each image
var filter2 = ee.Filter.and(maxDiffFilter, greaterEqFilter)
// This join will find all images before, sorted in ascending order
// This will gives us images so that closest is last
var join2 = ee.Join.saveAll({
  matchesKey: 'before',
  ordering: 'system:time_start',
  ascending: true})
  
var join2Result = join2.apply({
  primary: join1Result,
  secondary: join1Result,
  condition: filter2
})

// Each image now as a property called 'before' containing
// all images that come after it within the time-window
print(join2Result.first())


// Do the interpolation

// We now write a function that will be used to interpolate all images
// This function takes an image and replaces the masked pixels
// with the interpolated value from before and after images.

var interpolateImages = function(image) {
  var image = ee.Image(image)
  // We get the list of before and after images from the image property
  // Mosaic the images so we a before and after image with the closest unmasked pixel
  var beforeImages = ee.List(image.get('before'))
  var beforeMosaic = ee.ImageCollection.fromImages(beforeImages).mosaic()
  var afterImages = ee.List(image.get('after'))
  var afterMosaic = ee.ImageCollection.fromImages(afterImages).mosaic()

  // Interpolation formula
  // y = y1 + (y2-y1)*((t – t1) / (t2 – t1))
  // y = interpolated image
  // y1 = before image
  // y2 = after image
  // t = interpolation timestamp
  // t1 = before image timestamp
  // t2 = after image timestamp
  
  // We first compute the ratio (t – t1) / (t2 – t1)

  // Get image with before and after times
  var t1 = beforeMosaic.select('timestamp').rename('t1')
  var t2 = afterMosaic.select('timestamp').rename('t2')

  var t = image.metadata('system:time_start').rename('t')

  var timeImage = ee.Image.cat([t1, t2, t])

  var timeRatio = timeImage.expression('(t - t1) / (t2 - t1)', {
    't': timeImage.select('t'),
    't1': timeImage.select('t1'),
    't2': timeImage.select('t2'),
  })
  // You can replace timeRatio with a constant value 0.5
  // if you wanted a simple average
  
  // Compute an image with the interpolated image y
  var interpolated = beforeMosaic
    .add((afterMosaic.subtract(beforeMosaic).multiply(timeRatio)))
  // Replace the masked pixels in the current image with the average value
  var result = image.unmask(interpolated)
  return result.copyProperties(image, ['system:time_start'])
}

// map() the function to interpolate all images in the collection
var dataset = ee.ImageCollection(join2Result.map(interpolateImages))

//reduction _mean
var im_mean = dataset.reduce({
reducer: ee.Reducer.intervalMean(10, 90)});

var reprojected = im_mean
        .reproject(CRSzone, null, 10);
      
var final_image = reprojected.clip(ROI);

Map.addLayer(final_image, {
  bands: ['B4_mean', 'B3_mean', 'B2_mean'],
  min: 0,
  max: 0.5,
  gamma: [0.95, 1.1, 1]
},'RGB_01_03');

  //Bandes brutes
var B11_mean1 = final_image.select('B11_mean');
var B12_mean1 = final_image.select('B12_mean');

  //Spectral indices
var evi1 = final_image.expression ('(2.5*nir-red*(nir+6*red-7.5*bleue)+1)', {
      'nir': final_image.select('B8_mean'),
      'red': final_image.select('B4_mean'),
      'bleue': final_image.select('B2_mean'),
}).rename('EVI');
//Map.addLayer(evi1,{min:1,max:2},'EVI_01_03');

                                 ////////////////// PERIODE 2 //////////////////////


var s2 = ee.ImageCollection("COPERNICUS/S2_SR_HARMONIZED");

var filtered = s2
  .filter(ee.Filter.date('2022-04-01','2022-06-30'))
  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 50))
  .filter(ee.Filter.bounds(ROI))

print('S2 - Collection P2',filtered.size());

// Write a function for Cloud masking
function maskCloudAndShadowsSR(image) {
  var cloudProb = image.select('MSK_CLDPRB');
  var snowProb = image.select('MSK_SNWPRB');
  var cloud = cloudProb.lt(5);
  var snow = snowProb.lt(5);
  var scl = image.select('SCL'); 
  var shadow = scl.eq(3); // 3 = cloud shadow
  var cirrus = scl.eq(10); // 10 = cirrus
  // Cloud probability less than 5% or cloud shadow classification
  var mask = (cloud.and(snow)).and(cirrus.neq(1)).and(shadow.neq(1));
  return image.updateMask(mask).divide(10000)
      .select("B.*")
      .copyProperties(image, ["system:time_start"]);
}

var filtered = filtered.map(maskCloudAndShadowsSR)

// Add a band containing timestamp to each image
// This will be used to do pixel-wise interpolation later
var filtered = filtered.map(function(image) {
  var timeImage = image.metadata('system:time_start').rename('timestamp')
  // The time image doesn't have a mask. 
  // We set the mask of the time band to be the same as the first band of the image
  var timeImageMasked = timeImage.updateMask(image.mask().select(0))
  return image.addBands(timeImageMasked)
})

// Specify the time-window
// This will determine how much backward and forward are we willing to
// look for an unmasked pixel in the time-series
var days = 30

// For each image in the collection, we need to find all images
// before and after the specified time-window

// This is accomplished using Joins
// We need to do 2 joins
// Join 1: Join the collection with itself to find all images before each image
// Join 2: Join the collection with itself to find all images after each image

// We first define the filters needed for the join

// Define a maxDifference filter to find all images within the specified days
// The filter needs the time difference in milliseconds
// Convert days to milliseconds
var millis = ee.Number(days).multiply(1000*60*60*24)
var maxDiffFilter = ee.Filter.maxDifference({
  difference: millis,
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})

// We need a lessThanOrEquals filter to find all images after a given image
// This will compare the given image's timestamp against other images' timestamps
var lessEqFilter = ee.Filter.lessThanOrEquals({
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})

// We need a greaterThanOrEquals filter to find all images before a given image
// This will compare the given image's timestamp against other images' timestamps
var greaterEqFilter = ee.Filter.greaterThanOrEquals({
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})

// Apply the joins

// For the first join, we need to match all images that are after the given image.
// To do this we need to match 2 conditions
// 1. The resulting images must be within the specified time-window of target image
// 2. The target image's timestamp must be lesser than the timestamp of resulting images
// Combine two filters to match both these conditions
var filter1 = ee.Filter.and(maxDiffFilter, lessEqFilter)
// This join will find all images after, sorted in descending order
// This will gives us images so that closest is last
var join1 = ee.Join.saveAll({
  matchesKey: 'after',
  ordering: 'system:time_start',
  ascending: false})
  
var join1Result = join1.apply({
  primary: filtered,
  secondary: filtered,
  condition: filter1
})
// Each image now as a property called 'after' containing
// all images that come after it within the time-window
print(join1Result.first())

// Do the second join now to match all images within the time-window
// that come before each image
var filter2 = ee.Filter.and(maxDiffFilter, greaterEqFilter)
// This join will find all images before, sorted in ascending order
// This will gives us images so that closest is last
var join2 = ee.Join.saveAll({
  matchesKey: 'before',
  ordering: 'system:time_start',
  ascending: true})
  
var join2Result = join2.apply({
  primary: join1Result,
  secondary: join1Result,
  condition: filter2
})

// Each image now as a property called 'before' containing
// all images that come after it within the time-window
print(join2Result.first())


// Do the interpolation

// We now write a function that will be used to interpolate all images
// This function takes an image and replaces the masked pixels
// with the interpolated value from before and after images.

var interpolateImages = function(image) {
  var image = ee.Image(image)
  // We get the list of before and after images from the image property
  // Mosaic the images so we a before and after image with the closest unmasked pixel
  var beforeImages = ee.List(image.get('before'))
  var beforeMosaic = ee.ImageCollection.fromImages(beforeImages).mosaic()
  var afterImages = ee.List(image.get('after'))
  var afterMosaic = ee.ImageCollection.fromImages(afterImages).mosaic()

  // Interpolation formula
  // y = y1 + (y2-y1)*((t – t1) / (t2 – t1))
  // y = interpolated image
  // y1 = before image
  // y2 = after image
  // t = interpolation timestamp
  // t1 = before image timestamp
  // t2 = after image timestamp
  
  // We first compute the ratio (t – t1) / (t2 – t1)

  // Get image with before and after times
  var t1 = beforeMosaic.select('timestamp').rename('t1')
  var t2 = afterMosaic.select('timestamp').rename('t2')

  var t = image.metadata('system:time_start').rename('t')

  var timeImage = ee.Image.cat([t1, t2, t])

  var timeRatio = timeImage.expression('(t - t1) / (t2 - t1)', {
    't': timeImage.select('t'),
    't1': timeImage.select('t1'),
    't2': timeImage.select('t2'),
  })
  // You can replace timeRatio with a constant value 0.5
  // if you wanted a simple average
  
  // Compute an image with the interpolated image y
  var interpolated = beforeMosaic
    .add((afterMosaic.subtract(beforeMosaic).multiply(timeRatio)))
  // Replace the masked pixels in the current image with the average value
  var result = image.unmask(interpolated)
  return result.copyProperties(image, ['system:time_start'])
}

// map() the function to interpolate all images in the collection
var dataset = ee.ImageCollection(join2Result.map(interpolateImages))

//reduction _mean
var im_mean = dataset.reduce({
reducer: ee.Reducer.intervalMean(30, 40)});

var reprojected = im_mean
        .reproject(CRSzone, null, 10);
      
var final_image = reprojected.clip(ROI);

Map.addLayer(final_image, {
  bands: ['B4_mean', 'B3_mean', 'B2_mean'],
  min: 0,
  max: 0.5,
  gamma: [0.95, 1.1, 1]
},'RGB_04_06');

  //Bandes brutes
var B11_mean2 = final_image.select('B11_mean');
var B12_mean2 = final_image.select('B12_mean');

  //Spectral indices
var evi2 = final_image.expression ('(2.5*nir-red*(nir+6*red-7.5*bleue)+1)', {
      'nir': final_image.select('B8_mean'),
      'red': final_image.select('B4_mean'),
      'bleue': final_image.select('B2_mean'),
}).rename('EVI');
//Map.addLayer(evi2,{min:1,max:2},'EVI_04_06');

                       //////////////////// PERIODE 3 //////////////////////



var s2 = ee.ImageCollection("COPERNICUS/S2_SR_HARMONIZED");

var filtered = s2
  .filter(ee.Filter.date('2022-07-01','2022-09-30'))
  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 50))
  .filter(ee.Filter.bounds(ROI))

print('S2 - Collection P3',filtered.size());

// Write a function for Cloud masking
function maskCloudAndShadowsSR(image) {
  var cloudProb = image.select('MSK_CLDPRB');
  var snowProb = image.select('MSK_SNWPRB');
  var cloud = cloudProb.lt(5);
  var snow = snowProb.lt(5);
  var scl = image.select('SCL'); 
  var shadow = scl.eq(3); // 3 = cloud shadow
  var cirrus = scl.eq(10); // 10 = cirrus
  // Cloud probability less than 5% or cloud shadow classification
  var mask = (cloud.and(snow)).and(cirrus.neq(1)).and(shadow.neq(1));
  return image.updateMask(mask).divide(10000)
      .select("B.*")
      .copyProperties(image, ["system:time_start"]);
}

var filtered = filtered.map(maskCloudAndShadowsSR)

// Add a band containing timestamp to each image
// This will be used to do pixel-wise interpolation later
var filtered = filtered.map(function(image) {
  var timeImage = image.metadata('system:time_start').rename('timestamp')
  // The time image doesn't have a mask. 
  // We set the mask of the time band to be the same as the first band of the image
  var timeImageMasked = timeImage.updateMask(image.mask().select(0))
  return image.addBands(timeImageMasked)
})

// Specify the time-window
// This will determine how much backward and forward are we willing to
// look for an unmasked pixel in the time-series
var days = 30

// For each image in the collection, we need to find all images
// before and after the specified time-window

// This is accomplished using Joins
// We need to do 2 joins
// Join 1: Join the collection with itself to find all images before each image
// Join 2: Join the collection with itself to find all images after each image

// We first define the filters needed for the join

// Define a maxDifference filter to find all images within the specified days
// The filter needs the time difference in milliseconds
// Convert days to milliseconds
var millis = ee.Number(days).multiply(1000*60*60*24)
var maxDiffFilter = ee.Filter.maxDifference({
  difference: millis,
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})

// We need a lessThanOrEquals filter to find all images after a given image
// This will compare the given image's timestamp against other images' timestamps
var lessEqFilter = ee.Filter.lessThanOrEquals({
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})

// We need a greaterThanOrEquals filter to find all images before a given image
// This will compare the given image's timestamp against other images' timestamps
var greaterEqFilter = ee.Filter.greaterThanOrEquals({
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})

// Apply the joins

// For the first join, we need to match all images that are after the given image.
// To do this we need to match 2 conditions
// 1. The resulting images must be within the specified time-window of target image
// 2. The target image's timestamp must be lesser than the timestamp of resulting images
// Combine two filters to match both these conditions
var filter1 = ee.Filter.and(maxDiffFilter, lessEqFilter)
// This join will find all images after, sorted in descending order
// This will gives us images so that closest is last
var join1 = ee.Join.saveAll({
  matchesKey: 'after',
  ordering: 'system:time_start',
  ascending: false})
  
var join1Result = join1.apply({
  primary: filtered,
  secondary: filtered,
  condition: filter1
})
// Each image now as a property called 'after' containing
// all images that come after it within the time-window
print(join1Result.first())

// Do the second join now to match all images within the time-window
// that come before each image
var filter2 = ee.Filter.and(maxDiffFilter, greaterEqFilter)
// This join will find all images before, sorted in ascending order
// This will gives us images so that closest is last
var join2 = ee.Join.saveAll({
  matchesKey: 'before',
  ordering: 'system:time_start',
  ascending: true})
  
var join2Result = join2.apply({
  primary: join1Result,
  secondary: join1Result,
  condition: filter2
})

// Each image now as a property called 'before' containing
// all images that come after it within the time-window
print(join2Result.first())


// Do the interpolation

// We now write a function that will be used to interpolate all images
// This function takes an image and replaces the masked pixels
// with the interpolated value from before and after images.

var interpolateImages = function(image) {
  var image = ee.Image(image)
  // We get the list of before and after images from the image property
  // Mosaic the images so we a before and after image with the closest unmasked pixel
  var beforeImages = ee.List(image.get('before'))
  var beforeMosaic = ee.ImageCollection.fromImages(beforeImages).mosaic()
  var afterImages = ee.List(image.get('after'))
  var afterMosaic = ee.ImageCollection.fromImages(afterImages).mosaic()

  // Interpolation formula
  // y = y1 + (y2-y1)*((t – t1) / (t2 – t1))
  // y = interpolated image
  // y1 = before image
  // y2 = after image
  // t = interpolation timestamp
  // t1 = before image timestamp
  // t2 = after image timestamp
  
  // We first compute the ratio (t – t1) / (t2 – t1)

  // Get image with before and after times
  var t1 = beforeMosaic.select('timestamp').rename('t1')
  var t2 = afterMosaic.select('timestamp').rename('t2')

  var t = image.metadata('system:time_start').rename('t')

  var timeImage = ee.Image.cat([t1, t2, t])

  var timeRatio = timeImage.expression('(t - t1) / (t2 - t1)', {
    't': timeImage.select('t'),
    't1': timeImage.select('t1'),
    't2': timeImage.select('t2'),
  })
  // You can replace timeRatio with a constant value 0.5
  // if you wanted a simple average
  
  // Compute an image with the interpolated image y
  var interpolated = beforeMosaic
    .add((afterMosaic.subtract(beforeMosaic).multiply(timeRatio)))
  // Replace the masked pixels in the current image with the average value
  var result = image.unmask(interpolated)
  return result.copyProperties(image, ['system:time_start'])
}

// map() the function to interpolate all images in the collection
var dataset = ee.ImageCollection(join2Result.map(interpolateImages))

//reduction _mean
var im_mean = dataset.reduce({
reducer: ee.Reducer.intervalMean(30, 40)});

var reprojected = im_mean
        .reproject(CRSzone, null, 10);
      
var final_image = reprojected.clip(ROI);

Map.addLayer(final_image, {
  bands: ['B4_mean', 'B3_mean', 'B2_mean'],
  min: 0,
  max: 0.5,
  gamma: [0.95, 1.1, 1]
},'RGB_07_09');

  //Bandes brutes
var B11_mean3 = final_image.select('B11_mean');
var B12_mean3 = final_image.select('B12_mean');

  //Spectral indices
var evi3 = final_image.expression ('(2.5*nir-red*(nir+6*red-7.5*bleue)+1)', {
      'nir': final_image.select('B8_mean'),
      'red': final_image.select('B4_mean'),
      'bleue': final_image.select('B2_mean'),
}).rename('EVI');
//Map.addLayer(evi3,{min:1,max:2},'EVI_07_09');

                          ///////////////////// PERIODE 4 ///////////////////////

var s2 = ee.ImageCollection("COPERNICUS/S2_SR_HARMONIZED");

var filtered = s2
  .filter(ee.Filter.date('2022-10-01','2022-12-30'))
  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 50))
  .filter(ee.Filter.bounds(ROI))

print('S2 - Collection P4',filtered.size());

// Write a function for Cloud masking
function maskCloudAndShadowsSR(image) {
  var cloudProb = image.select('MSK_CLDPRB');
  var snowProb = image.select('MSK_SNWPRB');
  var cloud = cloudProb.lt(5);
  var snow = snowProb.lt(5);
  var scl = image.select('SCL'); 
  var shadow = scl.eq(3); // 3 = cloud shadow
  var cirrus = scl.eq(10); // 10 = cirrus
  // Cloud probability less than 5% or cloud shadow classification
  var mask = (cloud.and(snow)).and(cirrus.neq(1)).and(shadow.neq(1));
  return image.updateMask(mask).divide(10000)
      .select("B.*")
      .copyProperties(image, ["system:time_start"]);
}

var filtered = filtered.map(maskCloudAndShadowsSR)

// Add a band containing timestamp to each image
// This will be used to do pixel-wise interpolation later
var filtered = filtered.map(function(image) {
  var timeImage = image.metadata('system:time_start').rename('timestamp')
  // The time image doesn't have a mask. 
  // We set the mask of the time band to be the same as the first band of the image
  var timeImageMasked = timeImage.updateMask(image.mask().select(0))
  return image.addBands(timeImageMasked)
})

// Specify the time-window
// This will determine how much backward and forward are we willing to
// look for an unmasked pixel in the time-series
var days = 30

// For each image in the collection, we need to find all images
// before and after the specified time-window

// This is accomplished using Joins
// We need to do 2 joins
// Join 1: Join the collection with itself to find all images before each image
// Join 2: Join the collection with itself to find all images after each image

// We first define the filters needed for the join

// Define a maxDifference filter to find all images within the specified days
// The filter needs the time difference in milliseconds
// Convert days to milliseconds
var millis = ee.Number(days).multiply(1000*60*60*24)
var maxDiffFilter = ee.Filter.maxDifference({
  difference: millis,
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})

// We need a lessThanOrEquals filter to find all images after a given image
// This will compare the given image's timestamp against other images' timestamps
var lessEqFilter = ee.Filter.lessThanOrEquals({
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})

// We need a greaterThanOrEquals filter to find all images before a given image
// This will compare the given image's timestamp against other images' timestamps
var greaterEqFilter = ee.Filter.greaterThanOrEquals({
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})

// Apply the joins

// For the first join, we need to match all images that are after the given image.
// To do this we need to match 2 conditions
// 1. The resulting images must be within the specified time-window of target image
// 2. The target image's timestamp must be lesser than the timestamp of resulting images
// Combine two filters to match both these conditions
var filter1 = ee.Filter.and(maxDiffFilter, lessEqFilter)
// This join will find all images after, sorted in descending order
// This will gives us images so that closest is last
var join1 = ee.Join.saveAll({
  matchesKey: 'after',
  ordering: 'system:time_start',
  ascending: false})
  
var join1Result = join1.apply({
  primary: filtered,
  secondary: filtered,
  condition: filter1
})
// Each image now as a property called 'after' containing
// all images that come after it within the time-window
print(join1Result.first())

// Do the second join now to match all images within the time-window
// that come before each image
var filter2 = ee.Filter.and(maxDiffFilter, greaterEqFilter)
// This join will find all images before, sorted in ascending order
// This will gives us images so that closest is last
var join2 = ee.Join.saveAll({
  matchesKey: 'before',
  ordering: 'system:time_start',
  ascending: true})
  
var join2Result = join2.apply({
  primary: join1Result,
  secondary: join1Result,
  condition: filter2
})

// Each image now as a property called 'before' containing
// all images that come after it within the time-window
print(join2Result.first())


// Do the interpolation

// We now write a function that will be used to interpolate all images
// This function takes an image and replaces the masked pixels
// with the interpolated value from before and after images.

var interpolateImages = function(image) {
  var image = ee.Image(image)
  // We get the list of before and after images from the image property
  // Mosaic the images so we a before and after image with the closest unmasked pixel
  var beforeImages = ee.List(image.get('before'))
  var beforeMosaic = ee.ImageCollection.fromImages(beforeImages).mosaic()
  var afterImages = ee.List(image.get('after'))
  var afterMosaic = ee.ImageCollection.fromImages(afterImages).mosaic()

  // Interpolation formula
  // y = y1 + (y2-y1)*((t – t1) / (t2 – t1))
  // y = interpolated image
  // y1 = before image
  // y2 = after image
  // t = interpolation timestamp
  // t1 = before image timestamp
  // t2 = after image timestamp
  
  // We first compute the ratio (t – t1) / (t2 – t1)

  // Get image with before and after times
  var t1 = beforeMosaic.select('timestamp').rename('t1')
  var t2 = afterMosaic.select('timestamp').rename('t2')

  var t = image.metadata('system:time_start').rename('t')

  var timeImage = ee.Image.cat([t1, t2, t])

  var timeRatio = timeImage.expression('(t - t1) / (t2 - t1)', {
    't': timeImage.select('t'),
    't1': timeImage.select('t1'),
    't2': timeImage.select('t2'),
  })
  // You can replace timeRatio with a constant value 0.5
  // if you wanted a simple average
  
  // Compute an image with the interpolated image y
  var interpolated = beforeMosaic
    .add((afterMosaic.subtract(beforeMosaic).multiply(timeRatio)))
  // Replace the masked pixels in the current image with the average value
  var result = image.unmask(interpolated)
  return result.copyProperties(image, ['system:time_start'])
}

// map() the function to interpolate all images in the collection
var dataset = ee.ImageCollection(join2Result.map(interpolateImages))

//reduction _mean
var im_mean = dataset.reduce({
reducer: ee.Reducer.intervalMean(30, 40)});

var reprojected = im_mean
        .reproject(CRSzone, null, 10);
      
var final_image = reprojected.clip(ROI);

Map.addLayer(final_image, {
  bands: ['B4_mean', 'B3_mean', 'B2_mean'],
  min: 0,
  max: 0.5,
  gamma: [0.95, 1.1, 1]
},'RGB_10_12');

  //Bandes brutes

var B11_mean4 = final_image.select('B11_mean');
var B12_mean4 = final_image.select('B12_mean');

  //Spectral indices
var evi4 = final_image.expression ('(2.5*nir-red*(nir+6*red-7.5*bleue)+1)', {
      'nir': final_image.select('B8_mean'),
      'red': final_image.select('B4_mean'),
      'bleue': final_image.select('B2_mean'),
}).rename('EVI');
//Map.addLayer(evi4,{min:1,max:2},'EVI_10_12');

                         ////////////////////// Textures /////////////////////////

//S1
var vvmean_1_Byte = vvmeanb_1.unitScale(-30, 10).multiply(255).toByte();
var glcm = vvmean_1_Byte.glcmTexture({size: 1});

//Map.addLayer(vvmean_1_Byte)
//Map.addLayer(glcm,{},'VVmean_glcm');

var contrast = glcm.select('VV_mean_contrast');
var correlation = glcm.select('VV_mean_corr');
var entropy = glcm.select('VV_mean_ent');

//Stack VVmeans
var newTVVmeans = ee.Image([correlation, entropy]);
var T_VVmean1 = contrast.addBands(newTVVmeans);
//Map.addLayer(stackTVVmeans,{},'stackTVVmeans')


//S2
var evi1_Byte = evi1.unitScale(1, 2.5).multiply(255).toByte();
var glcm = evi1_Byte.glcmTexture({size: 1});

//Map.addLayer(evi1_Byte)
//Map.addLayer(glcm,{},'EVI_glcm')

var contrast = glcm.select('EVI_contrast');
var correlation = glcm.select('EVI_corr');
var entropy = glcm.select('EVI_ent');

//Stack EVIs
var newTevis = ee.Image([correlation, entropy]);
var T_EVI1 = contrast.addBands(newTevis);
//Map.addLayer(stackTevis,{},'stackTevis')


////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////// Export des données /////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////// EXPORT SENTINEL 1 ////////////////////////////

var vv_p5_1 = vv_p5_1.clip(ROI);
Export.image.toDrive({
  image: vv_p5_1,
  folder: dossier,
  description: 'vv_p5_1',
  scale: 10,
  maxPixels: 1303663927,
  crs:CRSzone,
  crsTransform:'',
  region: ROI
});

var vv_p5_2 = vv_p5_2.clip(ROI);
Export.image.toDrive({
  image: vv_p5_2, 
  folder: dossier,
  description: 'vv_p5_2',
  scale: 10,
  maxPixels: 1303663927,
  crs:CRSzone,
  crsTransform:'',
  region: ROI
});

var vv_p5_3 = vv_p5_3.clip(ROI);
Export.image.toDrive({
  image: vv_p5_3 ,
  folder: dossier,
  description: 'vv_p5_3',
  scale: 10,
  maxPixels: 1303663927,
  crs:CRSzone,
  crsTransform:'',
  region: ROI
});

var vv_p5_4 = vv_p5_4.clip(ROI);
Export.image.toDrive({
  image: vv_p5_4 ,
  folder: dossier,
  description: 'vv_p5_4',
  scale: 10,
  maxPixels: 1303663927,
  crs:CRSzone,
  crsTransform:'',
  region: ROI
});

var T_VVmean1 = T_VVmean1.clip(ROI);
Export.image.toDrive({
  image: T_VVmean1 ,
  folder: dossier,
  description: 'T_VVmean1',
  scale: 10,
  maxPixels: 1303663927,
  crs:CRSzone,
  crsTransform:'',
  region: ROI
});

//////////////////// EXPORT SENTINEL 2 ////////////////////////////

var B11_mean1 = B11_mean1.clip(ROI);
Export.image.toDrive({
  image: B11_mean1 ,
  folder: dossier,
  description: 'B11_mean1',
  scale: 10,
  maxPixels: 1303663927,
  crs:CRSzone,
  crsTransform:'',
  region: ROI
});

var B12_mean1 = B12_mean1.clip(ROI);
Export.image.toDrive({
  image: B12_mean1 
 , folder: dossier,
  description: 'B12_mean1',
  scale: 10,
  maxPixels: 1303663927,
  crs:CRSzone,
  crsTransform:'',
  region: ROI
});

var B11_mean2 = B11_mean2.clip(ROI);
Export.image.toDrive({
  image: B11_mean2 
 , folder: dossier,
  description: 'B11_mean2',
  scale: 10,
  maxPixels: 1303663927,
  crs:CRSzone,
  crsTransform:'',
  region: ROI
});

var B12_mean2 = B12_mean2.clip(ROI);
Export.image.toDrive({
  image: B12_mean2 
 , folder: dossier,
  description: 'B12_mean2',
  scale: 10,
  maxPixels: 1303663927,
  crs:CRSzone,
  crsTransform:'',
  region: ROI
});

var B11_mean3 = B11_mean3.clip(ROI);
Export.image.toDrive({
  image: B11_mean3 
 , folder: dossier,
  description: 'B11_mean3',
  scale: 10,
  maxPixels: 1303663927,
  crs:CRSzone,
  crsTransform:'',
  region: ROI
});

var B12_mean3 = B12_mean3.clip(ROI);
Export.image.toDrive({
  image: B12_mean3 
 , folder: dossier,
  description: 'B12_mean3',
  scale: 10,
  maxPixels: 1303663927,
  crs:CRSzone,
  crsTransform:'',
  region: ROI
});

var B11_mean4 = B11_mean4.clip(ROI);
Export.image.toDrive({
  image: B11_mean4 
 , folder: dossier,
  description: 'B11_mean4',
  scale: 10,
  maxPixels: 1303663927,
  crs:CRSzone,
  crsTransform:'',
  region: ROI
});

var B12_mean4 = B12_mean4.clip(ROI);
Export.image.toDrive({
  image: B12_mean4 
 , folder: dossier,
  description: 'B12_mean4',
  scale: 10,
  maxPixels: 1303663927,
  crs:CRSzone,
  crsTransform:'',
  region: ROI
});

var evi1 = evi1.clip(ROI);
Export.image.toDrive({
  image: evi1 
 , folder: dossier,
  description: 'evi1',
  scale: 10,
  maxPixels: 1303663927,
  crs:CRSzone,
  crsTransform:'',
  region: ROI
});

var evi2 = evi2.clip(ROI);
Export.image.toDrive({
  image: evi2 
 , folder: dossier,
  description: 'evi2',
  scale: 10,
  maxPixels: 1303663927,
  crs:CRSzone,
  crsTransform:'',
  region: ROI
});

var evi3 = evi3.clip(ROI);
Export.image.toDrive({
  image: evi3 
 , folder: dossier,
  description: 'evi3',
  scale: 10,
  maxPixels: 1303663927,
  crs:CRSzone,
  crsTransform:'',
  region: ROI
});

var evi4 = evi4.clip(ROI);
Export.image.toDrive({
  image: evi4 
 , folder: dossier,
  description: 'evi4',
  scale: 10,
  maxPixels: 1303663927,
  crs:CRSzone,
  crsTransform:'',
  region: ROI
});

var T_EVI1 = T_EVI1.clip(ROI);
Export.image.toDrive({
  image: T_EVI1 
 , folder: dossier,
  description: 'T_EVI1',
  scale: 10,
  maxPixels: 1303663927,
  crs:CRSzone,
  crsTransform:'',
  region: ROI
});